<div>

<h4 class="m1">Software Testing</h4>

<p class="strong">Ziele</p>
<ul class="2">
    <li>Bewertung von Arbeitsergebnissen</li>
    <li>Verifizierung von Anforderungen</li>
    <li>Prüfung auf Vollständigkeit, Validierung der Funktionalitäten</li>
    <li>Aufdecken von Fehlerwirkungen und Fehlerzuständen</li>
    <li>Schaffen von Vertrauen in Qualität</li>
    <li>Bereitstellen von Informationen</li>
    <li>Schaffen von Standardkonformität und Compliance</li>
</ul>

<p class="strong">Begriffe</p>
<ul class="m2">
    <li><span class="strong">Fehlhandlung</span><br>durch z.B. Zeitdruck, mangelnde Erfahrung, Missverständnisse</li>
    <li><span class="strong">Fehlerzustand</span><br>Was ist Grundursache?</li>
    <li><span class="strong">Fehlerwirkung</span></li>
</ul>

<p class="strong">Grundsätze</p>
<ul class="m2">
    <li>Testen zeigt die Anwesenheit von Fehlerzuständen, nicht der Abwesenheit</li>
    <li>Vollständiges Testen ist nicht möglich</li>
    <li>Frühes Testen spart Zeit und Geld</li>
    <li>Häufung von Fehlerzuständen</li>
    <li>Pestizid-Paradoxon</li>
    <li>Test ist kontextabhängig</li>
    <li>Trugschluss: “keine Fehler“ bedeutet ein brauchbares System</li>
</ul>

<p class="strong">Testprozess</p>
<ul class="m2">
    <li>Testplanung</li>
    <li>Testüberwachung und -steuerung</li>
    <li>Testanalyse</li>
    <li>Testentwurf</li>
    <li>Testrealisierung</li>
    <li>Testdurchführung</li>
    <li>Testabschluss</li>
</ul>

<p class="strong">Techniken</p>	

<img src="img/testing/testing1.jpg" class= "iW-700 m3" alt="testing">
 
<p class="strong">Development Life Cycle Process</p>
<ul class="m2">
    <li>Aktivitäten innerhalb des Development-Prozesses</li>
    <li>Logische und zeitliche Anhängigkeiten</li>
    <li>Sequenzielle Modelle (Wasserfall-Modell)</li>
    <li>Iterative und inkrementelle Modelle
        <ul>
            <li>Schleifen zur Überprüfung bei diversen Programmabschnitten</li>
        </ul>
    </li>
</ul>

<p class="strong">Best Practice</p>	
<ul class="m2">
    <li>Für jede Dev-Aktivität existieren entsprechende Testaktivitäten (von Zeit und Budget abhängig)</li>
    <li>Stufenspezifische Ziele für das Testen</li>
    <li>Testanalyse und -entwurf beginnen frühzeitig</li>
    <li>Tester*innen nehmen sich in das Development eingebunden (z.B. Beträge zum Requirements  Engineering)</li>
    <li>Tipp: es sollte einem selber nicht egal sein wie das Ergebnis aussieht</li>
</ul>

<p class="m3 strong">A/B – Test</p>

<h4>Software Engineering</h4>
<p class="fS-08 kursiv m1">Modelle und Ansätze</p>

<p class="strong">Definition</p>
<p class="m3">(ist die) zielorientierte Bereitstellung und systematische Verwendung von Prinzipien, Methoden und Werkzeugen für die arbeitsteilige, ingenieurmäßige Entwicklung und Anwendung von Softwaresystemen.</p>

<p class="strong">Teilgebiete</p>
<ul class="m3">
    <li>Softwareentwicklung</li>
    <li>Projektmanagement</li>
    <li>Qualitätssicherung</li>
    <li>Softwaretechnologie</li>
</ul>

<p class="strong">Wasserfallmodell</p>
<ul class="m3">
    <li>Anforderungen – Lastenheft/Briefing</li>
    <li>Analyse/Entwurf – Pflichtenheft/Feinkonzept</li>
    <li>Implementierung – Software</li>
    <li>Überprüfung/Testen</li>
    <li>Wartung</li>
</ul>

<p class="strong">V-Modell</p>
<ul class="m3">
    <li>Anforderungsdefinition - Abnahmetest (UAT-User Aceptenz Test)</li>
    <li>Grobentwurf - Systemtest</li>
    <li>Feinentwurf - Integrationstest</li>
    <li>Modulimplementation - Modultest</li>
</ul>

<p class="strong">Prototypmodell</p>
<p>Ziel: Frühzeitige Entwicklung ablauffähiger Modelle</p>
<ul class="m2">
    <li>Anforderungen ermitteln, präzisieren und vervollständigen</li>
    <li>Umsetzbarkeit einzelner Anforderungen erproben</li>
    <li>Lösungsalternativen darstellen und evaluieren</li>
    <li>prinzipielle Durchführbarkeit nach nachweisen</li>
    <li>praktische Erfahrungen sammeln (zB.: neue Technologien)</li>
</ul>

<p >Vorgehensweisen</p>	
<ul class="m2">
    <li>vertikaler Prototyp kleiner Ausschnitt der gesamten Anwendung wird mit möglichst allen Schichten realisiert</li>
    <li>horizontaler Prototyp : einzelne Schicht (z.B. Benutzeroberfläche, Datenzugriff) wird vollständig realisiert, ohne das eine Anbindung an eine andere Schicht existiert</li>
</ul>

<p >Zweck und Arten</p>
<ul class="m2">
    <li>inkrementelle Weiterentwicklung: Prototyp wird Bestandteil der fertigen Software</li>
    <li>Wegwerf-Prototyp: Quick und Dirty</li>
    <li>Klärung von Problemen: Erkenntnisgewinn als Ziel, Beziehung zur fertigen Software zu Beginn nicht festgelegt</li>
</ul>

<p>Vorteile</p>
<ul class="m2">
    <li>Entwicklungsrisiken verringern</li>
    <li>Planungsgrundlage verbessern</li>
</ul>

<p>Nachteile</p>
<ul class="m2">
    <li>Höherer Aufwand</li>
    <li>Nicht Erkennen von Beschränkungen des Prototyps</li>
</ul>

<p class="strong">Evolutionäres/inkrementelles Modell</p>
<ul class="m2">
    <li>Betrachtung eines Ausschnitts der gesamten Software (zB. Kernanforderungen)</li>
    <li>Umsetzung und Auslieferung des realisierten Teils</li>
    <li>Sammeln von Erfahrungen und Identifikation von Anforderungen für Weiterentwicklung</li>
</ul>

<p>Variante</p>	
<ul class="m2">
    <li>möglichst vollständige Analyse der Anforderungen</li>
    <li>Realisierung von Ausschnitten der Anforderungen in aufeinander aufbauenden Versionen</li>
</ul>

<p class="strong">Agile</p>	
<p class="fS-08 m1">https://agilemanifesto.org</p>

<p>Hintergrund</p>
<ul class="m2">
    <li>globaler Wettbewerb, schnell veränderndes Umfeld</li>
    <li>schnelle Reaktion auf neu Gelegenheiten, Märkte und Rahmenbedingungen notwendig</li>
    <li>Steigende Bereitschaft, Qualität und Anforderungen gegen Quick Wins einzutauschen</li>
    <li>iterativer und inkrementeller Charakter</li>
    <li>versucht bürokratischen Aufwand zu vermeiden</li>
    <li>versucht flexibel auf Veränderungen zu reagieren</li>
    <li>stelle funktionierende Software in den Mittelpunkt nicht deren Dokumentation</li>
    <li>weniger Regeln für die praktische Arbeit</li>
    <li>definiert ein schlankes Vorgehensmodell</li>
</ul>

<p>Vorteile </p>
<ul class="m2">
    <li>sich ändernde Anforderungen werden berücksichtigt</li>
    <li>häufiges Kundenfeedback</li>
    <li>fördert die Zusammenarbeit im Dev-Team</li>
</ul>

<p>Nachteile</p>	
<ul class="m3">
    <li>klare inhaltliche Vorgaben zu Projektbeginn schwer möglich</li>
    <li>Kunde muss bereits sein, sich in den Dev-Prozess zu integrieren</li>
    <li>Risiko lückenhafte Dokumentation</li>
    <li>passt nicht zu den Strukturen großer Organisationen</li>
</ul>









</div>